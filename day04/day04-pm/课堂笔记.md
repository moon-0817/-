# async-await
async/await 是ES7提出的基于Promise的解决异步的最终方案
async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象resolve的值。因此对async函数可以直接then，返回值就是then方法传入的函数。
await 也是一个修饰符，只能放在async定义的函数内。可以理解为等待。


# generator
Genertor 函数是es6 新增的一种异步编程的解决方案，语法和传统的函数完全不同；Genertor 函数的最大的特点就是可以交出函数的执行权（即暂停执行）
对于Generator 函数也可以叫做生成器函数
调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束

# 继承
 Man 使用Stu的属性和方法来继承
 原型链继承 类式继承 组合继承 寄生继承

 # class 继承 

 #### 封装
 　封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。私有的数据可以用两种方式来间接的控制。第一种方法，我们使用传统的存、取方法。第二种方法我们用属性（property）。
 #### 继承
 继承主要实现重用代码，节省开发时间。
 #### 多态
 重载
 配合arguments，根据传入的参数不同，执行不同的函数体

 arguments
 一个类数组对象，包含所有传入的参数，是实现重载的一种工具

 重构
 父对象构造出来的属性和方法，都可以在子对象中重新定义

 # es6模块化语法
 ####  1.默认导出：
 export default { 默认导出的成员名称}
#### 按需导出和按需导入
export 需要导出的成员
#### 直接导入并直接执行该模块的代码
有时候只是想执行某模块的代码，并不需要其中向外暴露的成员，此时可以直接导入并执行模块代码。
import  './index.js'

# 原型 原型链
每个函数都有作为构造函数的潜质，因此每个函数都有一个隐式的 prototype 属性，指向这个函数的原型对象。所谓的原型对象就是一个隐藏的实例，这个实例被用于建立构造函数和实例的联系。实例中的 proto 也指向这个原型对象。于是，实例和构造函数的关系就建立起来了。简而言之，proto 永远指向构造函数的原型对象，也就是构造函数的 prototype：
//原型 原型链
，/对象【4}，〔],function
1/函数 有原型
prototype
有原型链
proto
浏览器看到的
1/构造函数--->new-->对象
，构造函数.prototype
//对象。proto==对象proto构造函数
.prototype对象的原型链 指向 构造函数的
<!-- 继承的方式 原型继承 组合继承 类式继承 寄生继承 -->
// export defalut  与 export 区别？

//export defalut 导出一次      export 多次
//export defalut 导出的     导入语法：import 变量名 from 文件路径
//export        导出的      导入语法：import { 和导出的名字一样 as 别名 } from 文件路径